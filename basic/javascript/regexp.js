/**
 * 建立正则表达式的两种方式
 *      对象字面量: var reg = /abc/g;
 *      构造函数：var reg = new RegExp('anc', 'g');
 *      
 * 正则对象的属性
 *      i: 执行忽略大小写的匹配
 *      g: 执行全局匹配
 *      m: 执行多行匹配
 *      u: 可以匹配4字节的unicode编码
 * 
 * 正则对象的方法
 *      test: 返回布尔值，验证是否匹配模式，如果带有g修饰符，则每次从上一次结束的位置开始匹配
 *      exec: 返回匹配的结果，匹配成功返回装有匹配结果的数组，失败返回null，如果包含圆括号，则数组包括多个元素
 * 
 * 字符串对象的方法
 *      match: 与exec方法方法比较类似，在加g修饰符的时候不一样，match放回所有匹配元素，exec方法返回一个
 *      search: search方法会返回匹配成功后的索引，会自动忽略g修饰符
 *      replace: 替换匹配成功的结果，加g的话，则替换全部匹配的，第二个参数可以使用$符合，也可以是一个函数
 *      split: split('字符串的分割正则','返回数组的最大成员数')
 * 
 * 语法
 *      类：[abc], [a-z], [A-Z], [123], [0-9]
 *      预定义类：
 *          \s = [\t\n\x0B\f\r]:  空格
 *          \S = [^\t\n\x0B\f\r]: 非空格
 *          \d = [0-9]: 数字
 *          \D = [^0-9]: 非数字
 *          \w = [a-zA-Z_0-9]: 单词字符（字母、数字、下划线）
 *          \W = [^a-zA-Z_0-9]: 非单词字符
 *          . = [^\r\n]: 任意字符，除了回车与换行外所有字符
 *          \f = \x0c \cL: 匹配一个换页符
 *          \n = \x0a \cJ: 匹配一个换行符
 *          \r = \x0d \cM: 匹配一个回车符
 *          \t = \x09 \cI: 匹配一个制表符
 *          \v = \x0b \cK: 匹配一个垂直制表符
 *      量词：表示匹配多少个目标对象
 *          n * = {0,}:  匹配零个或多个n
 *          n + = {1,}:  匹配至少一个 n 的字符串
 *          n ? = {0,1}:  匹配零个或一个n
 *          {n}:  匹配n次
 *          {n,m}:  匹配n到m次
 *          {n,}:  至少匹配n次
 *      边界：
 *          ^： 以xx开始，在类 []中表示非
 *          $： 以xx结束
 *          \b： 单词边界
 *          \B： 非单词边界
 * 
 *      分组：使用（），作用是提取相匹配的字符串，使量词作用于分组
 *          或： 分组中使用 | 可以达到或的效果
 *          反向引用： 使用 ()后可以使用 $1- $9等来匹配
 *          后向引用： \n 表示后向引用,\1表示第一个（）中的内容，\2表示第二个，以此类推
 *          分组命名： ES2018是通过数字命名的，现在可以命名名称
 *          忽略分组： 不希望捕获某些分组，在分组内加上 (?:)即可
 *          前瞻：匹配规则的时候，向后检查是否符合断言, 只匹配一个位置，右边的东西是不会放进结果的
 *              正向前瞻：(?=) 后面要有xx
 *              负向前瞻：(?!) 后面不能有xx
 *          后顾：匹配规则的时候，向前检查是否符合断言, 只匹配一个位置，右边的东西是不会放进结果的
 *              正向后顾：(?<=) 前面要有xx
 *              负向后顾：(?<!) 前面不能有xx
 * 
 *      贪婪模式与非贪婪模式
 *          正则表达式在匹配的时候尽可能多的匹配叫贪婪模式，在限定符后加？可以进行非贪婪匹配
 * 
 *      优先级
 *          优先级从高到低：转义 \ ---> 括号 ()、 (?:)、 (?=)、 [] ---> 字符和位置 ---> 或 |
 */

var str = '_x_x_';
var reg = /x/g;
console.log('reg', reg.test(str), reg.lastIndex);

var str1 = '_x_x_a_x_x_b_';
var reg1 = /_(x)_(x)_/;
console.log('reg1', reg1.exec(str1));

var str2 = '_x_x_';
var reg2 = /x/g;
console.log('reg2', str2.replace(reg2, 'y'));

// 给字符串加千分符
var str3 = '1233231234234';
var reg3 = /(?=(?!b)(\d{3})+$)/g;
console.log('reg3', str3.replace(reg3, ','));

// 反向引用
'2018-02-10'.replace(/(\d{4})\-(\d{2})\-(\d{2})/, '$2/$3/$1');

// 后向引用
var reg4 = /\d{4}(\-|\/|.)\d{1,2}\1\d{1,2}/;
var bool4_1 = reg4.test('2018-02-12');
var bool4_2 = reg4.test('2018/02/12');
var bool4_3 = reg4.test('2018.02.12');
var bool4_4 = reg4.test('2018.02-12');
console.log('reg4', bool4_1, bool4_2, bool4_3, bool4_4);

// 分组命名
var reg5 = /(?<year>\d{4})-(?<month>\d{1,2})-(?<day>\d{1,2})/;
var result5 = reg5.exec('2018-02-12');
console.log('reg5', result5.groups.year, result5.groups.month, result5.groups.day);

// 忽略分组
var reg6 = /(?:tom).(o).(k)/;
console.log('reg6', 'tom.o.k'.replace(reg6, '$2.$1'));

// 前瞻
var reg7_1 = /\w(?=\d)/g;
var reg7_2 = /\w(?!\d)/g;
var result7_1 = '1a2bc*456v8'.replace(reg7_1, '-');
var result7_2 = '1a2bc*456v8'.replace(reg7_2, '-');
console.log('reg7', result7_1, result7_2);

// 后顾
var reg8_1 = /(?<=\$)\d+/;
var reg8_2 = /(?<!\$)\d+/;
console.log('reg8', reg8_1.exec('$42'), reg8_2.exec('$42'));

// 贪婪与非贪婪
var reg9_1 = /\d{3,6}/;
var reg9_2 = /\d{3,6}?/;
var reg9_3 = /ab+?/;
console.log('reg9', '12345678'.replace(reg9_1, '-'), '12345678'.replace(reg9_2, '-'), 'abbbb'.replace(reg9_3, '-'));

// 校验基本日期格式
var reg10 = /^\d{4}(\-|\/|\.)\d{1,2}\1\d{1,2}$/;
console.log('reg10', reg10.test('2018-09-10'));

// 校验密码强度
var reg11 = /^(?=.*\d)(?=.*[a-z])(?=.*[A-Z]).{8,10}$/;
console.log('reg11', reg11.test('2018310aZ'));

// 校验正文
var reg12 = /^[\u4e00-\u9fa5]{0,}$/;
console.log('reg12', reg12.test('中国'));

// 校验E-Mail
var reg13 = /[\w!#$%&'*+/=?^_`{|}~-]+(?:\.[\w!#$%&'*+/=?^_`{|}~-]+)*@(?:[\w](?:[\w-]*[\w])?\.)+[\w](?:[\w-]*[\w])?/;
console.log('reg13', reg13.test('2831518478@qq.com'));

// 检验身份证号码
var reg14_1 = /^[1-9]\d{7}((0\d)|(1[0-2]))(([0|1|2]\d)|3[0-1])\d{3}$/;
var reg14_2 = /^[1-9]\d{5}[1-9]\d{3}((0\d)|(1[0-2]))(([0|1|2]\d)|3[0-1])\d{3}([0-9]|X)$/;
console.log('reg14', reg14_1.test('342901911110187'), reg14_2.test('342901199111101872'));

// 检验金额
var reg15 = /^[0-9]+(.[0-9]{2})?$/;
console.log('reg15', reg15.test('15.21'), reg15.test('15.01'), reg15.test('15'));

// 校验手机号
var reg16 = /^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\d{8}$/;
console.log('reg16', reg16.test('13003696610'));

// 检验IE的版本
var reg17 = /^.*MSIE [5-8](?:\.[0-9]+)?(?!.*Trident\/[5-9]\.0).*$/;
console.log('reg17', reg17.test('MSIE/5.0 (Windows NT 10.0; WOW64; Trident/7.0; .NET4.0C; .NET4.0E; InfoPath.3; rv:11.0) like Gecko'));

// 检验IP-v4地址
var reg18 = /\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\b/;
console.log('reg18', reg18.test('127.0.0.1'));

// 检验IP-v6地址
var reg18 = /(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))/;
console.log('reg18', reg18.test('127.0.0.1'));

// 检验url的前缀
var reg19 = /^[a-zA-Z]+:\/\//;
console.log('reg19', reg19.test('http://www.baidu.com'));

// 提取网页图片
var reg20 = /\< *[img][^\>]*[src] *= *[\"\']{0,1}([^\"\'\ >]*)/;
console.log('reg20', reg20.test('<img src="asdf"/>'));

// 查找css属性
var reg21 = /^\s*[a-zA-Z\-]+\s*[:]{1}\s[a-zA-Z0-9\s.#]+[;]{1}/;
console.log('reg21', reg21.test('color: red;'));

// 抽取注释
var reg22 = /<!--(.*?)-->/;
console.log('reg22', reg22.test('<!-- abc -->'));

// 特殊字符包括emoij
var reg23 = /[\ud800\udbff-\udc00\udfff\ud800-\udfff]/;
console.log('reg23', reg23.test('𠂆'));