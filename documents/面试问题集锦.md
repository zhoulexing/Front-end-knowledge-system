## html

-   浏览器的渲染原理？

    见浏览器渲染.md。

-   什么是渐进式渲染？在实际工作中有哪些具体的例子？

    渐进式渲染是用于提高网页性能，以尽快呈现页面的技术。
    具体有图片懒加载、css 和脚本的按需加载、异步加载 html 片段。

## css

-   简单说下盒模型（box-sizing）？如何理解 width、 height、margin、padding、border？

    box-sizing 定义了一个元素该如何计算总宽度和总高度。有三种，分别是 content-box、border-box、padding-box，padding-box 很少用。

    元素的 width 分为外部尺寸和内部尺寸，外部尺寸的流特性有正常流宽度，即铺满整个容器；
    格式化宽度，仅出现在绝对定位元素中，表现出包裹性。内部尺寸的流特性有包裹性、首选最小宽度、
    最大宽度。

    margin、padding 百分比无论是水平方向还是垂直方向都是相对于父元素的宽度计算的，border 不支持百分比。

-   margin 合并的 3 种场景？ 如何理解 margin 为 auto？ 如何利用 margin 实现垂直居中？

    答：1）相邻兄弟元素 margin 合并； 2）父级和第一个/最后一个子元素； 3）空块级元素的 margin 合并。

    margin: auto; 在自适应的方向上会根据剩余空间进行自动安排。

    1）通过 writing-moode 改变文档流的方向； 2）利用绝对定位元素，将四个方向的定位都设为 0，让其在横向和竖向都有自适应特性，
    然后改变宽高，通过 margin:auto 实现垂直居中；

-   如何理解内联元素？

    字母 x 的下边缘就是内联元素的基线；ex 的单位就是指 x 的高低；行距的计算公式:行距 = line-height - font-size，font-size 的大小
    就是三线格的高度；line-height 不能改变替换元素的高度，只能改变文本的高度，同样 line-height 改变块级元素的高度是通过改变内联级别
    的元素占据的高度；

    vertical-align 是相对于 line-height 值进行计算的；vertical-align：middle 中的 middle 指的是基线往上 1/2x-height 高度；
    vertical-align 百分比是相对于 line-height 计算的；

    内联元素的宽高不起作用；内联元素的 padding、margin 和 border 都起作用，但不影响布局；

    内联元素默认的高度只和 font-size 有关；

    line-height 相对于 font-size 进行计算；div 的高度由 line-height 决定不是 font-size 决定；

-   float 与 absolute 在一起能起作用吗？

    不能，float 会失效。另外 absolute 是非常独立的 css 属性值，其样式和行为表现不依赖其他任何 css 属性就可以完成，
    没有设置 top/right/bottom/left 则相当于相对定位；

-   clear: left | right | both 为何能清楚浮动？

    元素设置了 clear，则表明此元素两边不允许有浮动元素，为了满足它，所以不能将流元素和浮动元素放一起。
    又因为在计算元素的宽高时是根据元素的实际位置进行计算的，所以清楚浮动后父元素高度能够撑起来。

-   如何理解 BFC（块级格式化上下文）? 有哪些属性可生产 BFC？

    块级格式化上下文是 css 可视化渲染的一部分，在一个区域内，规定了内部元素的渲染方式，以及浮动元素之间的影响关系。

    1. BFC 就像是一道屏障，隔离出一道区域，是内部和外部渲染互不影响；
    2. BFC 的区域不会和外部的浮动区域发生叠加，也就是说外部任何浮动元素和 BFC 区域是泾渭分明的；
    3. BFC 在计算内部高度的时候，浮动元素也会计算在内；
    4. BFC 内部的元素会紧靠着浮动元素进行布局。

    浮动元素（float 不为 none）、绝对定位元素（position 为 absolute 和 fixed）、行内块元素（display 为 inline-block）、
    表格单元格（display 为 table-cell）、overflow 值不为 visible 的块元素、弹性元素（display 为 flex 或 inline-flex）、
    网格元素（display 为 grid 或 inline-grid）、多列容器（元素的 column-count 或 column-width 不为 auto）。

-   如何实现水平居中和垂直居中？

    答：见 basic/html-css/layout.html

-   letter-spacing、word-spacing 区别？

    letter-spacing 表示单词之间的间隔；word-spacing 表示空格该如何处理，之所以 word-spacing 叫 word-spacing 不叫 blank-spacing
    是因为英文中单词是已空格进行分隔的，要想控制单词之间的间距，只能向空格进行开刀。word-spacing 可以作用于&nbsp、space、tab 和换
    行敲出来的空格。

-   换行相关的属性以及如何使用？

    对于文字的排版主要要考虑以下几个情况：空格的处理（是否合并）,换行的处理（回车换行和自动换行）,断词的处理（英文单词）。

    white-space 是用来处理空格和换行的。 有如下几个值：normal、nowrap、pre(preserve)、pre-wrap、pre-line。normal 表示连续的空白符会被合并，
    换行符会被当作空白符来处理。nowrap 表示永不换行，pre 表示空格和换行全部保留
    下来，但自动换行没了。pre-wrap 表示保留空格和换行符，且可以自动换行。pre-line 空格被合并，换行和自动换行保留。

    word-break 是控制单词如何被拆分换行的。它有三个值 normal、break-all、keep-all。keep-all 表示一律不拆分换行、只有空格可以触发自动换行。
    break-all 表示所有单词碰到边界一律拆分换行。

    word-wrap 是用来控制单词是如何被拆分换行的，有两个值 normal、break-word。break-word 表示只有当一个单词一整行都显示不下时，才会拆分换行该单词。

-   如何利用 content 实现计数器？

    ```
    ol {
    counter-reset: section;
    list-style-type: none;
    }
    li:before {
    counter-increment: section;
    content: counters(section, ".") " ";
    }

    ```

-   如何理解 css 层叠？

    在 css 世界中，z-index 属性只有和定位元素（position 不为 static 的元素）在一起的时候才有作用；
    但随着 css3 新世界的到来，z-index 已经并非只对定位元素有效，flex 盒子的子元素也可以设置 z-index 属性。

    css2.1 层叠顺序为 background/border、负 z-index、block、float、inline、z-index:auto|0、正 z-index。

-   线性渐变中的按角度渐变，这个角度是怎么计算的？

    角度是以盒子的垂直平分线作为轴，然后顺时针旋转角度进行渐变。

## js

-   防抖和节流有什么区别？分别如何实现？

    防抖是在一段时间内只会执行一次，节流是在一段时间内按照设定的延迟时间间隔执行。
    具体实现见 basic/javascript/throttleAndDebounce.js。

-   js 中 clientWidth、clientLeft、offsetWidth、offsetLeft、scrollWidth、scrollLeft、
    window.innerWidth、window.outerWidth、window.screenLeft、window.screenX 之间的区别？
    window.getComputedStyle 方法获取到的宽高是什么宽高？位置是什么位置？dom.getBoundingClientRect 获取到的又是什么？

    clientWidth 表示元素的宽度 + 内边距的宽度，clientLeft 表示宽度的起点距离外边框的距离，即边框的宽度；
    offsetWidth 表示元素的宽度 + 内边距的宽度 + 边框的宽度，offsetLeft 表示外边框相对于第一个相对定位的父级元素的距离；
    scrollWidth 表示元素的宽度 + 内边距的距离 + 滚动区域的宽度, scrollLeft 表示滚动的位置相对于顶点的距离。

    window.getComputedStyle 获取到的是整合后的 css 样式属性值对象; dom.getBoundingClientRect 获取到的是一个元素相对根节点
    的上下左右坐标以及宽高。

-   js 如何获取父节点、子节点和兄弟节点？

    API 中 node 是包含空格、换行、文本等，element 才是元素（不包含文本）。获取父节点：dom.parentNode、dom.parentElement、
    dom.offsetParent（获取所有的父节点）；获取子节点：dom.childNodes、dom.children、dom.firstChild、dom.firstElementChild、
    dom.lastChild、dom.lastElementChild； 获取兄弟节点：dom.previousSibling、dom.previousElementSibling、dom.nextSibling、
    dom.nextElementSibling。

-   获取 js 对象属性的方法有哪些？ 每个方法是否能获取原型上的属性？

    有 Object.keys、for in、getOwnPropertyNames；
    Object.keys 和 getOwnPropertyNames 只能获取对象上的枚举属性，for in 能获取原型链对象上新加的属性，
    对于 for in 可以通过 hasOwnProperty 方法来过滤掉原型链上的属性。

-   浏览器中的垃圾回收机制与内存泄漏？什么时候出发垃圾回收？

    浏览器的 javascript 具有自动垃圾回收机制(GC)，也就是说执行环境会负责管理代码执行过程中的内存。
    垃圾回收器会定期的去检查环境中的垃圾，然后进行清除。对于变量是否有用和无用，主要采用标记清除和
    引用计数的方法。

    标记清除主要是对环境中的标量进行标记，对于那些标记为无用的变量，垃圾回收器会进行清除。

    引用计数主要是对变量的引用进行计数，如果一个变量被引用，则该值的引用次数加 1，同理会减 1，对于引用
    次数为 0 的变量，垃圾回收期会进行清除。

    对于 js 引擎主要采用的是标记清除，即遍历所有可访问的对象，回收已不可访问的对象。当然在这个基础上有
    优化，最主要的是以下两个优化方案：分代回收和增量GC。

    分代回收的方案是将对象分为“临时对象区”和“持久对象”区，对于临时对象区多回收，持久对象区少回收。

    增量GC的方案很简单，就是每次处理一点，下次再处理一点。