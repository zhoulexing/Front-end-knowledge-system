## SYN 和 ACK 的全称是啥？ARP 协议是啥？

SYN: synchronize；
ACK: acknowledgement；
ARP 协议是一种以解析地址的协议，根据 IP 地址而解析除 mac 地址的协议；

## URL（Uniform Resource Locator） 和 URI（Uniform Resource Identifier） 的区别？

URI 使用字符串标识某一互联网资源，而URL标识资源的地点。可见URL是URI的子集。

## TCP 为啥要 3 次握手和 4 次挥手？

图片见 images/TCP 三次握手，案例说只需要两次即可，但需要三次是因为客户端在向服务端发送第一次请求连接时，可能会因为网络等其他原因失效，
导致在后期服务端接收到请求。如果是两次握手的话，这种情况就会形成一次失效的连接，从而增加服务器开销。

图片见 images/TCP 四次挥手，四次是因为服务端在接收到客户端发送的关闭连接的消息时，可能还有数据未传完，所以服务端会先发送一个消息给
客户端，告诉它我知道了，然后把数据传输完，最后告诉客户端关闭连接，客户端收到消息就关闭连接。

如果是客户端突然挂掉了，为了处理这种情况，服务器会设置保活计时器，就发送探测报文段，若发送了 10 个探测报文段，每一个相隔 75 秒，还没有响应
就认为客户端出了故障，从而终止连接。

## 什么是 SYN 攻击？

攻击客户端在短时间内伪造大量不存在的 IP 进行访问，由于源地址是不存在的，所以服务端会不断的重发直至超时，这些伪造的 SYN 包将长时间占用未连接队列，
正常的 SYN 请求被丢弃，导致目标系统运行缓慢，严重者会引起网络堵塞，导致系统瘫痪。

## https 为什么安全？

因为 https 保证了传输的安全，防止传输过程被监听、防止数据被窃取、可以确认网络的安全性。

## https 的传输过程是怎样的？

客户端生成一个加密的随机数，加密方法如 RSA 公钥加密，然后向服务端发起请求；服务端也会生成一个加密随机数字，加密算法跟客户端一样，
然后将数字证书返回给客户端，客户端拿到数字证书后进行验证。验证过程包含以下几点：

1. 验证域名、有效期；
2. 判断证书来源是否合法；
3. 判断证书是否被篡改，需要与 CA 服务器进行校验；
4. 判断正式是否已被吊销。

验证不通过，就会向访问者显示一个警告，由其选择是否还要继续通信。验证通过的情况下，会在本地生成一个随机数，通过证书里的公钥加密，然后传给服务端；
服务端拿到加密后的随机数通过私钥进行解密拿到随机数；然后通过三个随机数双方商定加密方法，然后对数据进行加密传输给客户端，客户端拿到数据后利用本
地的随机数进行解密。

## 为什么一定要三个随机数？

三个随机数一同生成的秘钥不容易被猜出，一个伪随机数可能完全不随机，每增加一个自由度，随机性增加的可不是一。

## SSL/TLS 协议？

SSL 和 TLS 协议就是 HTTPS 协议相对 HTTP 协议多出来的加密的部分。

## 为什么需要证书？

防止中间人攻击。

## 针对 HTTPS 抓包流程？

1. 抓包工具捕获 Client 发送给 Server 请求，并伪装成客户端向服务端发起请求；
2. 服务端收到请求后，返回数字证书，并用根证书进行解密，获取到服务器的 CA 证书公钥。然后抓包工具伪造自己的 CA 证书，发送给客户端；
3. 客户端收到返回之后，和上面的流程一样，进行证书校验、然后利用抓包工具的公钥进行加密，生成协商密码，
4. 抓包工具捕获到 Client 发来的重要信息，通过私钥进行解密，获取到协商密码。然后使用服务器之前返回的公钥生成协商密码，并发送给服务器；
5. 服务器收到消息之后，通过私钥解密获取协商密码，对数据进行加密发送至抓包工具；
6. 抓包工具截获密文，并用协商密码进行解密，再用自己伪造证书的私钥进行加密传给客户端；
7. 客户端拿到加密信息后，用公钥解开，验证 HASH，整个过程就完成了信任；
8. 在整个过程中，最重要的就是根证书，因为它伪造的 CA 证书是能获得双方信任的关键。

## nodejs 创建 https server？

1. openssl genrsa -out key.pem
2. openssl req -new -key key.pem -out csr.pem
3. openssl x509 -req -days 9999 -in csr.pem -signkey key.pem -out cert.pem
4. rm csr.pem

## 浏览器端如何缓存？

web 缓存分为数据库数据缓存、服务器端缓存、浏览器端缓存、web 应用层缓存。浏览器缓存分为两种，分别从新鲜度和校验值
两个维度来规定浏览器是直接使用本次缓存的数据，还是去拿新的数据，也就是强缓存和协商缓存。这两种缓存都是通过设置
协议头来控制。

### 强缓存

1. Cache-Control：max-age=xxx(单位是 s) | s-maxage=xxx（单位是 s，只用于共享缓存如 CDN）| public | private | no-cache | no-store | must-revalidate
2. Expires：过期时间
   缓存过期时间，cache-control 的优先级比 expires 高。之所以在有了 Expires 的情况下，还添加 Cache-Control，是因为 Expires 的值是过期时间，
   而且时间是根据客户端的时间进行比较，客户端的时间可进行修改，所以不是很准。而 Cache-Control 表示的是一段时间，所以即使客户端时间不准，
   也没关系。

### 协商缓存

1. Last-modified & If-modified-since： 服务器端文件的最后修改时间，是检查服务器端资源是否更新的一种方式。
2. Etag & If-None-Match： 根据实体内容生成一段 hash 字符串，标识资源的状态，由服务端生成。
   之所以在有了 Last-modified 之后，还需要添加 Etag，是因为 Last-modified 的精确度是 1s，如果在 1s 中内修改文件，它将
   不能准确标明文件的新鲜度。

## http2 有哪些优势？

1. 多路复用的单一长连接

-   单一长连接
    在 HTTP/2 中，客户端向某个域名的服务器请求页面的过程中，只会创建一条 TCP 连接，即使这页面可能包含上百个资源。
    单一的连接应该是 HTTP2 的主要优势，单一的连接能减少 TCP 握手带来的时延 。

-   多路复用
    HTTP2 虽然只有一条 TCP 连接，但是在逻辑上分成了很多 stream。 HTTP2 把要传输的信息分割成一个个二进制帧，
    首部信息会被封装到 HEADER Frame，相应的 request body 就放到 DATA Frame,一个帧你可以看成路上的一辆车,
    只要给这些车编号，让 1 号车都走 1 号门出，2 号车都走 2 号门出，就把不同的 http 请求或者响应区分开来了。

2. 头部压缩和二进制格式

HTTP2 搞了个 HPACK 压缩来压缩头部，减少报文大小(调试这样的协议将需要 curl 这样的工具，要进一步地分析网络数据
流需要类似 Wireshark 的 http2 解析器)。

3. 服务端推动 Sever Push

当一个客户端请求资源 X，而服务器知道它很可能也需要资源 Z 的情况下，服务器可以在客户端发送请求前，主动将资源 Z 推送给客户端。
