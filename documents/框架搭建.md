## 前言
架构，在前端会更负责，设计领域更广。在实现的过程中，除了考虑代码的**可用性**、**性能**、**模型构建**、**组件复用**等问题外，
还有前端特有的**平台设定**、**浏览器兼容**、**交互设计**、**用户体验**等相关的问题。在“大前端”的背景下，还需要深入**移动端设计**、
**桌面应用**、**物联网**等相关的问题。

### 前端架构

**没有一种架构能满足未来的需求**。在软件的生命周期中，架构可以不断地优化，持续地变好，使得架构可以适用于当前的场景。
所以**架构是可以改变的，架构是需要变化的**。

01. 为什么需要软件架构？

软件开发就像造房子一样，需要先规划、设计、实施，然后才能入住。对于软件开发来说也是类似的，需要规划、设计、开发，然后才能用。

02. 架构的设计

   - 收集利益相关者的需求
   - 与相应的技术人员讨论，了解架构上的潜在限制
   - 寻找潜在的可行性技术方案
   - 整理出功能列表中的功能性需求和跨功能性需求
   - 找出会严重影响开发的风险点
   - 和技术委员会、利益相关者反复确认方案
   - 对架构设计进行概念证明
   - 细化架构的部分实施细节
   - 结合技术和业务，进行需求排期

03. 架构设计原则

   - 不多也不少
   - 演进式
   - 持续性

04. 前端架构层次设计

   - 系统级
   - 应用级
   - 模块级
   - 组件级

### 架构基础：工作流设计

前端基础架构是一系列工具与流程的集合，它是我们在启动一个项目时所需要制定的一系列规范和规划。

01. 代码之旅：基础规范

   - 规范代码组织结构
   - 统一代码风格
   - 组件、函数等命名规范
   - 开发工具规范

02. 代码组织决定应用架构

   - 打开**README**了解应该阅读哪些相关的资料
   - 阅读**package.json**了解系统的基础设施、使用了哪些组件库，以及配置了哪些构建脚本
   - 浏览主目录下的一个个文件，了解系统的一些插件的配置
   - 进入项目代码中阅读和了解

03. 统一代码风格，避免架构腐烂

04. 使用Lint规范代码

05. 规范化命名，提升可读性

   - 命名法：驼峰命名法(getTypeById)、下划线命名(get_type_by_id)、匈牙利命名(熟悉+类型+对象描述如：strFirstName)

06. 规范开发工具，提升开发效率

07. 项目的文档化：README搭建指南

   - 支持运行的环境
   - 必要的依赖准备，以及如何搭建
   - 项目的安装指南
   - 线上的示例或最后哦的运行环境
   - 相关的文档链接
   - 相关人员的联系方式，讨论群Î

08. 绘制架构图：减少沟通成本

09. 可编辑文档库：提升协作性

10. 记录架构决策：轻量级架构决策记录

   - 标题
   - 日期
   - 描述决策相关的状态，包含提议、通过、完成、已弃用、已取代等
   - 价值中立的、用于描述事实上下文的背景
   - 应对这种场景的相应的决策
   - 记录应用决策后产生的结果
   

``` 
0001-examples.md
# 1. examples

## 日期

2020-01-01

## 状态

2020-01-01  提议

## 背景

在这里补充上下文。。。

## 决策

在这里补充决策信息。。。

## 后果 

在这里补充后果
```

11. 可视化文档：注重代码的可读性

12. 看板工具：统一管理业务知识

13. 提交信息：每次代码提交文档化

14. 通过流程化提高代码质量

15. 使用工具提升代码质量

   - 代码扫描工具：Sonar、CheckStyle
   - IED快速重构

16. 测试策略

   - 单元测试
   - 组件测试
   - 契约/接口测试
   - E2E集成测试/端到端测试

### 架构基础：设计构建流

构建系统是一个web应用不可缺少的一部分，其核心用途是，帮助开发者从源代码开发开始，构建出最后可用的目标软件。
包含一下一些事情：**依赖管理及安装**、**优化开发环境**、**代码质量检测**、**编译及打包**、**测试及部署**。

01. 依赖管理工具

   - bower
   - npm/yarn/cnpm
   - 本地文件

02. 软件包源管理

   - 基于源码版本管理服务器(公有/私有npm服务器、git服务器)

``` 
"dependencoes": {
    "adr": "git+http://github.com/phodal/adr/#v1.7.0"
}
```

   - 本地的软件依赖包

``` 
package.json
"aofe": "file:aofe"
```

   - 前端应用的编译
   - JavaScript的编译
   - css的编译
   - css in JavaScript
   - 模版编译

03. 前端代码的打包

04. 设计构建流

   - 构建工具：自动化任务
   - 使用包管理工具构建(npm)
   - 使用构建工具(Grunt/Gulp)
   - 使用打包工具构建(webpack)
   - 实现构建流

05. 持续交付

   - 部署方式(持续部署：完成即部署，常用于测试环境、自动化部署：需要人为介入、手动部署：全程人为操作)
   - 设计持续集成
   - 自动化部署
   - 环境配置
   - 开发环境配置
   - 线上调试

### 架构设计：组件化架构

将页面拆解为多个子页面、模版、组件等，其表现形式是基于组件的架构，又称为前端组件化。

01. 风格指南

用于文档编写和设计的标准，或者用于特定出版物，组织或领域的通用用法。

   - 原则与模式（亲密性、对齐、重复、对比）
   - 色彩

      - 主题色
      - 功能色
      - 中性色
      - primary(主题色)
      - secondary(次主题色)
      - success(成功色)
      - danger(危险色)
      - warning(警示色)
      - info(提示色)

   - 文字排印（大小、颜色、行高、字重及字体家族）
   - 布局

      - 栅格布局
      - flex布局

   - 组件
   - 文档及其他
   - 维护风格指南

02. 模式库

模式库与面向设计人员为主的风格指南略有不同，它是一个面向开发者视角的组件库、代码集。

   - 组件库

      - 创建组件库考虑点

         - 组件提供怎样的方式？一次引入所有还是按需加载？
         - 组件如何发布？
         - 复杂的组件是否使用外部组件，而非自己开发？
         - 对于复杂的组件，是否拆分成一个或多个组件，以降低维护成本？
         - 组件的反馈渠道。
         - 组件的发布策略。

      - 创建过程

         - 创建脚手架
         - 第一个组件
         - 进行发布测试
         - 创建组件的文档中心
         - 提供组件示例
         - 持续改进
         
       - 维护组件库

          - 自动化版本发布的semantic-release
          - 自动复查代码工具的Danger

   - 组件类型(2种分法)

      - 表单控制类，包含自动完成、输入框、单选框、选择器、滑动输入等
      - 导航类，包含菜单、侧边导航、工具栏等
      - 布局类，包含卡片、标签页、树型选择器、栅格列表、步骤条等
      - 按钮和指示器类，包含按钮、图标、进度条等
      - 弹框及对话框类，包含底部弹出框、对话框、提示框等
      - 数据表格类，包含分页器、排序表单等

      - 基础UI组件
      - 复合组件
      - 业务组件

  

### 架构设计：前后端分离架构

01. 前后端分离

   - 为什么选择前后端分离

      - 独立部署
      - 分清职责
      - 技术栈独立
      - 方便系统演进
      - 提高效率

   - 前后端分离的开发模式

      - 瀑布模式
      - 敏捷模式

   - 前后端分离的API设计

      - RESTful API
      - API与安全
      - 应对API变更

02. API管理模式：API文档管理模式

   - 传统方式

      - 手写word
      - 离线API文档
      - 在线API文档
      - 版本化API文档
      - 代码即文档

   - 互联网模式

      - HTTP服务即API文档
      - 代码生成可交互的API文档（Swagger）

03. 前后端并行开发：Mock Server

   - 三种类型Mock Server

      - 普通Mock Server：HTTP服务器
      - DSL形式的Mock Server
      - 编程型Mock Server

04. 服务于前端的后端：BFF

### 架构设计：微前端架构

01. 微前端

   - 为前端架构

      - 应用自治
      - 单一职责
      - 技术栈无关

   - 为前端优势

      - 遗留系统迁移
      - 后端解耦，前端聚合（不需要太多APP）
      - 热闹驱动开发

02. 微前端的技术拆分方式

   - 路由分发式
   通过反向代理的方式将不同的业务分发到不同的独立前端应用上。
   - 微前端服务化
   是微服务架构在前端的实施，每个前端应用都是完全独立（技术栈、开发、部署、构建独立）、自主运行的，
   最后通过模块化的方式组合出完整的前端应用。
   这种方式会导致一个页面上同时存在两个及以上的前端应用在运行。
   - 组合式集成：微应用化
   将系统按业务拆分成不同的目录，每个目录对应的业务由不同的团队开发，最终聚合在一起，这种方式
   只能使用唯一的一种前端框架。
   - 微件化
   微件是一段可以直接嵌入应用上运行的代码，它由开发人员预先编译好，在加载时不需要再做任何修改或编译。
   有点像webpack的热更新。
   

